-- Migration: 004_exactly_once.sql
-- Purpose: Add tables for exactly-once semantics (idempotent producers + transactions)
-- Date: 2026-02-03

-- ============================================================================
-- PRODUCER STATE (Idempotent Producers)
-- ============================================================================

-- Registered producers (for ID assignment and epoch tracking)
CREATE TABLE IF NOT EXISTS producers (
    id TEXT PRIMARY KEY,                    -- UUID generated by client or server
    organization_id TEXT,                   -- Optional: for multi-tenant isolation
    transactional_id TEXT,                  -- Optional: for transactional producers
    epoch INTEGER NOT NULL DEFAULT 0,       -- Incremented on producer restart (fencing)
    created_at INTEGER NOT NULL,
    last_heartbeat INTEGER NOT NULL,
    state TEXT NOT NULL DEFAULT 'active',   -- 'active', 'fenced', 'expired'
    metadata TEXT,                          -- JSON metadata (client info, etc.)
    UNIQUE(organization_id, transactional_id)
);

CREATE INDEX IF NOT EXISTS idx_producers_org ON producers(organization_id);
CREATE INDEX IF NOT EXISTS idx_producers_transactional ON producers(transactional_id);

-- Producer sequence tracking (for deduplication)
-- Stores the last sequence number seen for each producer/topic/partition combo
CREATE TABLE IF NOT EXISTS producer_sequences (
    producer_id TEXT NOT NULL,
    topic TEXT NOT NULL,
    partition_id INTEGER NOT NULL,
    last_sequence BIGINT NOT NULL DEFAULT -1,  -- -1 means no records yet
    updated_at INTEGER NOT NULL,
    PRIMARY KEY (producer_id, topic, partition_id),
    FOREIGN KEY (producer_id) REFERENCES producers(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_producer_seq_topic ON producer_sequences(topic, partition_id);

-- ============================================================================
-- TRANSACTIONS (Transactional Writes)
-- ============================================================================

-- Active and recent transactions
CREATE TABLE IF NOT EXISTS transactions (
    transaction_id TEXT PRIMARY KEY,        -- UUID
    producer_id TEXT NOT NULL,
    state TEXT NOT NULL DEFAULT 'ongoing',  -- 'ongoing', 'preparing', 'committed', 'aborted'
    timeout_ms INTEGER NOT NULL DEFAULT 60000,
    started_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    completed_at INTEGER,
    FOREIGN KEY (producer_id) REFERENCES producers(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_transactions_producer ON transactions(producer_id);
CREATE INDEX IF NOT EXISTS idx_transactions_state ON transactions(state);

-- Transaction partition tracking (which partitions are part of transaction)
CREATE TABLE IF NOT EXISTS transaction_partitions (
    transaction_id TEXT NOT NULL,
    topic TEXT NOT NULL,
    partition_id INTEGER NOT NULL,
    first_offset BIGINT NOT NULL,           -- First offset written in this txn
    last_offset BIGINT NOT NULL,            -- Last offset written (updated as records added)
    PRIMARY KEY (transaction_id, topic, partition_id),
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id) ON DELETE CASCADE
);

-- Transaction markers (written to segments to indicate commit/abort boundaries)
-- These are stored in metadata and also written as control records in segments
CREATE TABLE IF NOT EXISTS transaction_markers (
    id TEXT PRIMARY KEY,
    transaction_id TEXT NOT NULL,
    topic TEXT NOT NULL,
    partition_id INTEGER NOT NULL,
    offset BIGINT NOT NULL,                 -- Offset of the marker record
    marker_type TEXT NOT NULL,              -- 'commit' or 'abort'
    created_at INTEGER NOT NULL,
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_txn_markers_partition ON transaction_markers(topic, partition_id, offset);

-- ============================================================================
-- CONSUMER OFFSETS (Enhanced for Read-Committed)
-- ============================================================================

-- Add isolation level tracking to consumer groups
-- Note: This may need to be added to existing consumer_offsets table
-- For now, we create a separate config table

CREATE TABLE IF NOT EXISTS consumer_group_config (
    group_id TEXT PRIMARY KEY,
    isolation_level TEXT NOT NULL DEFAULT 'read_uncommitted',  -- 'read_uncommitted' or 'read_committed'
    enable_auto_commit INTEGER NOT NULL DEFAULT 1,
    auto_commit_interval_ms INTEGER NOT NULL DEFAULT 5000,
    session_timeout_ms INTEGER NOT NULL DEFAULT 30000,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

-- Last Stable Offset (LSO) tracking per partition
-- LSO = highest offset where all transactions below are committed/aborted
CREATE TABLE IF NOT EXISTS partition_lso (
    topic TEXT NOT NULL,
    partition_id INTEGER NOT NULL,
    last_stable_offset BIGINT NOT NULL DEFAULT 0,
    updated_at INTEGER NOT NULL,
    PRIMARY KEY (topic, partition_id)
);

-- ============================================================================
-- HELPER VIEWS
-- ============================================================================

-- View: Active producers (not fenced or expired)
CREATE VIEW IF NOT EXISTS active_producers AS
SELECT * FROM producers
WHERE state = 'active'
  AND last_heartbeat > (strftime('%s', 'now') * 1000 - 300000);  -- 5 min timeout

-- View: Pending transactions (ongoing or preparing)
CREATE VIEW IF NOT EXISTS pending_transactions AS
SELECT t.*, p.organization_id, p.transactional_id
FROM transactions t
JOIN producers p ON t.producer_id = p.id
WHERE t.state IN ('ongoing', 'preparing');

-- View: Transaction summary with partition counts
CREATE VIEW IF NOT EXISTS transaction_summary AS
SELECT
    t.transaction_id,
    t.producer_id,
    t.state,
    t.started_at,
    t.completed_at,
    COUNT(tp.partition_id) as partition_count,
    SUM(tp.last_offset - tp.first_offset + 1) as record_count
FROM transactions t
LEFT JOIN transaction_partitions tp ON t.transaction_id = tp.transaction_id
GROUP BY t.transaction_id;
