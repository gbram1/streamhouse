# Initiative 1.7: CLI Tool

**Timeline:** Week 6
**Goal:** Build a command-line interface for easy interaction and testing

---

## Overview

The **CLI Tool** (`streamctl`) provides a user-friendly interface for managing topics, producing, and consuming records. It's essential for:
- Development and testing
- Admin operations
- Debugging production issues
- Demos and documentation

Think of it as the equivalent of `kafka-console-producer`, `kafka-console-consumer`, and `kafka-topics` all in one tool.

---

## Command Structure

```
streamctl
├── topic            # Topic management
│   ├── create
│   ├── list
│   ├── describe
│   └── delete
├── produce          # Produce records
├── consume          # Consume records
├── group            # Consumer group management
│   ├── list
│   ├── describe
│   └── delete
└── segment          # Debug segment info
    ├── list
    └── dump
```

---

## Implementation

### Main CLI Structure

```rust
// crates/streamhouse-cli/src/main.rs

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "streamctl")]
#[command(about = "StreamHouse CLI tool", long_about = None)]
struct Cli {
    /// Server address
    #[arg(short, long, default_value = "http://localhost:50051")]
    server: String,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Topic management
    Topic {
        #[command(subcommand)]
        command: TopicCommands,
    },

    /// Produce records to a topic
    Produce(ProduceArgs),

    /// Consume records from a topic
    Consume(ConsumeArgs),

    /// Consumer group management
    Group {
        #[command(subcommand)]
        command: GroupCommands,
    },

    /// Segment debugging
    Segment {
        #[command(subcommand)]
        command: SegmentCommands,
    },
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Topic { command } => handle_topic_command(&cli.server, command).await?,
        Commands::Produce(args) => handle_produce(&cli.server, args).await?,
        Commands::Consume(args) => handle_consume(&cli.server, args).await?,
        Commands::Group { command } => handle_group_command(&cli.server, command).await?,
        Commands::Segment { command } => handle_segment_command(&cli.server, command).await?,
    }

    Ok(())
}
```

### Topic Commands

```rust
// crates/streamhouse-cli/src/commands/topic.rs

use clap::Subcommand;
use streamhouse::pb::admin_service_client::AdminServiceClient;
use streamhouse::pb::*;

#[derive(Subcommand)]
pub enum TopicCommands {
    /// Create a new topic
    Create {
        /// Topic name
        name: String,

        /// Number of partitions
        #[arg(short, long, default_value = "1")]
        partitions: i32,

        /// Retention time (e.g., "7d", "24h", "30m")
        #[arg(short, long)]
        retention: Option<String>,
    },

    /// List all topics
    List,

    /// Describe a topic
    Describe {
        /// Topic name
        name: String,
    },

    /// Delete a topic
    Delete {
        /// Topic name
        name: String,

        /// Skip confirmation
        #[arg(short, long)]
        yes: bool,
    },
}

pub async fn handle_topic_command(
    server: &str,
    command: TopicCommands,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut client = AdminServiceClient::connect(server.to_string()).await?;

    match command {
        TopicCommands::Create {
            name,
            partitions,
            retention,
        } => {
            let retention_ms = retention.map(parse_duration).transpose()?;

            let request = CreateTopicRequest {
                name: name.clone(),
                partition_count: partitions,
                retention_ms,
                config: std::collections::HashMap::new(),
            };

            client.create_topic(request).await?;

            println!("✅ Topic '{}' created with {} partition(s)", name, partitions);
        }

        TopicCommands::List => {
            let response = client.list_topics(ListTopicsRequest {}).await?;
            let topics = response.into_inner().topics;

            if topics.is_empty() {
                println!("No topics found");
                return Ok(());
            }

            println!("{:<30} {:<10} {:<15}", "NAME", "PARTITIONS", "RETENTION");
            println!("{:-<55}", "");

            for topic in topics {
                let retention = topic
                    .retention_ms
                    .map(|ms| format_duration(ms))
                    .unwrap_or_else(|| "infinite".to_string());

                println!(
                    "{:<30} {:<10} {:<15}",
                    topic.name, topic.partition_count, retention
                );
            }
        }

        TopicCommands::Describe { name } => {
            let request = GetTopicMetadataRequest { name: name.clone() };
            let response = client.get_topic_metadata(request).await?;
            let metadata = response.into_inner();

            println!("Topic: {}", metadata.name);
            println!("Partitions: {}", metadata.partition_count);
            println!();
            println!("{:<10} {:<15} {:<15}", "PARTITION", "HIGH WATERMARK", "EARLIEST");
            println!("{:-<40}", "");

            for partition in metadata.partitions {
                println!(
                    "{:<10} {:<15} {:<15}",
                    partition.partition_id, partition.high_watermark, partition.earliest_offset
                );
            }
        }

        TopicCommands::Delete { name, yes } => {
            if !yes {
                print!("Are you sure you want to delete topic '{}'? [y/N]: ", name);
                use std::io::{self, Write};
                io::stdout().flush()?;

                let mut input = String::new();
                io::stdin().read_line(&mut input)?;

                if !input.trim().eq_ignore_ascii_case("y") {
                    println!("Cancelled");
                    return Ok(());
                }
            }

            client.delete_topic(DeleteTopicRequest { name: name.clone() }).await?;
            println!("✅ Topic '{}' deleted", name);
        }
    }

    Ok(())
}

// Helper to parse duration strings like "7d", "24h", "30m"
fn parse_duration(s: String) -> Result<i64, String> {
    let s = s.trim();
    let (num_str, unit) = s.split_at(s.len() - 1);
    let num: i64 = num_str.parse().map_err(|_| format!("Invalid duration: {}", s))?;

    let multiplier = match unit {
        "s" => 1000,
        "m" => 60 * 1000,
        "h" => 60 * 60 * 1000,
        "d" => 24 * 60 * 60 * 1000,
        _ => return Err(format!("Unknown duration unit: {}", unit)),
    };

    Ok(num * multiplier)
}

fn format_duration(ms: i64) -> String {
    let days = ms / (24 * 60 * 60 * 1000);
    if days > 0 {
        return format!("{}d", days);
    }

    let hours = ms / (60 * 60 * 1000);
    if hours > 0 {
        return format!("{}h", hours);
    }

    let minutes = ms / (60 * 1000);
    if minutes > 0 {
        return format!("{}m", minutes);
    }

    format!("{}s", ms / 1000)
}
```

### Produce Command

```rust
// crates/streamhouse-cli/src/commands/produce.rs

use clap::Args;
use streamhouse::pb::producer_service_client::ProducerServiceClient;
use streamhouse::pb::*;
use std::io::{self, BufRead};
use std::path::PathBuf;

#[derive(Args)]
pub struct ProduceArgs {
    /// Topic name
    topic: String,

    /// Record key
    #[arg(short, long)]
    key: Option<String>,

    /// Record value (if not reading from stdin/file)
    #[arg(short, long)]
    value: Option<String>,

    /// Read records from file (one per line)
    #[arg(short, long)]
    file: Option<PathBuf>,

    /// Partition (default: auto-assign by key hash)
    #[arg(short, long)]
    partition: Option<i32>,
}

pub async fn handle_produce(
    server: &str,
    args: ProduceArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut client = ProducerServiceClient::connect(server.to_string()).await?;

    if let Some(file_path) = args.file {
        // Read from file
        let file = std::fs::File::open(file_path)?;
        let reader = io::BufReader::new(file);

        for (line_num, line) in reader.lines().enumerate() {
            let line = line?;
            if line.is_empty() {
                continue;
            }

            let response = client
                .produce(ProduceRequest {
                    topic: args.topic.clone(),
                    key: args.key.as_ref().map(|k| k.as_bytes().to_vec()),
                    value: line.as_bytes().to_vec(),
                    partition: args.partition,
                    timestamp: None,
                })
                .await?;

            let result = response.into_inner();
            println!(
                "[{}] partition={} offset={}",
                line_num + 1,
                result.partition,
                result.offset
            );
        }
    } else if let Some(value) = args.value {
        // Single value from CLI arg
        let response = client
            .produce(ProduceRequest {
                topic: args.topic.clone(),
                key: args.key.as_ref().map(|k| k.as_bytes().to_vec()),
                value: value.as_bytes().to_vec(),
                partition: args.partition,
                timestamp: None,
            })
            .await?;

        let result = response.into_inner();
        println!("partition={} offset={}", result.partition, result.offset);
    } else {
        // Read from stdin
        println!("Reading from stdin (Ctrl+D to finish)...");
        let stdin = io::stdin();

        for line in stdin.lock().lines() {
            let line = line?;
            if line.is_empty() {
                continue;
            }

            let response = client
                .produce(ProduceRequest {
                    topic: args.topic.clone(),
                    key: args.key.as_ref().map(|k| k.as_bytes().to_vec()),
                    value: line.as_bytes().to_vec(),
                    partition: args.partition,
                    timestamp: None,
                })
                .await?;

            let result = response.into_inner();
            println!("partition={} offset={}", result.partition, result.offset);
        }
    }

    Ok(())
}
```

### Consume Command

```rust
// crates/streamhouse-cli/src/commands/consume.rs

use clap::Args;
use streamhouse::pb::consumer_service_client::ConsumerServiceClient;
use streamhouse::pb::*;
use chrono::{DateTime, Utc};

#[derive(Args)]
pub struct ConsumeArgs {
    /// Topic name
    topic: String,

    /// Partition (default: 0)
    #[arg(short, long, default_value = "0")]
    partition: i32,

    /// Start offset
    #[arg(short = 'o', long)]
    offset: Option<i64>,

    /// Start from beginning
    #[arg(short = 'b', long)]
    from_beginning: bool,

    /// Start from latest
    #[arg(short = 'l', long)]
    from_latest: bool,

    /// Consumer group ID
    #[arg(short, long)]
    group: Option<String>,

    /// Follow mode (like tail -f)
    #[arg(short, long)]
    follow: bool,

    /// Max records per batch
    #[arg(short, long, default_value = "100")]
    max_records: i32,

    /// Show keys
    #[arg(short = 'k', long)]
    show_keys: bool,

    /// Show timestamps
    #[arg(short = 't', long)]
    show_timestamps: bool,
}

pub async fn handle_consume(
    server: &str,
    args: ConsumeArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut client = ConsumerServiceClient::connect(server.to_string()).await?;

    let start_offset = if args.from_beginning {
        -1 // earliest
    } else if args.from_latest {
        -2 // latest
    } else {
        args.offset.unwrap_or(0)
    };

    let request = ConsumeRequest {
        topic: args.topic.clone(),
        partition: args.partition,
        start_offset,
        max_records: args.max_records,
        max_wait_ms: if args.follow { 1000 } else { 0 },
        group_id: args.group.clone(),
    };

    let mut stream = client.consume(request).await?.into_inner();

    let mut record_count = 0;

    loop {
        match stream.message().await {
            Ok(Some(response)) => {
                for record in response.records {
                    record_count += 1;

                    // Format output
                    let mut parts = vec![];

                    parts.push(format!("offset={}", record.offset));

                    if args.show_timestamps {
                        let dt = DateTime::<Utc>::from_timestamp_millis(record.timestamp)
                            .unwrap_or_default();
                        parts.push(format!("timestamp={}", dt.format("%Y-%m-%d %H:%M:%S")));
                    }

                    if args.show_keys {
                        if let Some(key) = record.key {
                            parts.push(format!("key={}", String::from_utf8_lossy(&key)));
                        }
                    }

                    let value = String::from_utf8_lossy(&record.value);
                    parts.push(value.to_string());

                    println!("{}", parts.join(" | "));
                }

                if !args.follow && response.records.is_empty() {
                    break;
                }
            }
            Ok(None) => break,
            Err(e) => {
                eprintln!("Error: {}", e);
                break;
            }
        }
    }

    println!();
    println!("Consumed {} record(s)", record_count);

    Ok(())
}
```

---

## Usage Examples

### Topic Management

```bash
# Create a topic
streamctl topic create orders --partitions 3 --retention 7d

# List topics
streamctl topic list

# Describe a topic
streamctl topic describe orders

# Delete a topic
streamctl topic delete orders --yes
```

### Produce

```bash
# Produce a single message
streamctl produce orders --value '{"order_id": 123, "amount": 99.99}'

# Produce with key
streamctl produce orders --key user-123 --value '{"event": "click"}'

# Produce from file
streamctl produce orders --file events.jsonl

# Produce from stdin
echo '{"order_id": 456}' | streamctl produce orders

# Interactive mode
streamctl produce orders
Reading from stdin (Ctrl+D to finish)...
{"order_id": 1}
partition=0 offset=0
{"order_id": 2}
partition=0 offset=1
^D
```

### Consume

```bash
# Consume from beginning
streamctl consume orders --from-beginning

# Consume from specific offset
streamctl consume orders --offset 1000

# Consume from latest
streamctl consume orders --from-latest

# Follow mode (tail -f style)
streamctl consume orders --follow

# Consume with consumer group
streamctl consume orders --group analytics-group --follow

# Show keys and timestamps
streamctl consume orders -b -k -t
```

---

## Output Formatting

### JSON Pretty-Printing

```rust
// Add JSON detection and formatting
fn format_value(value: &[u8]) -> String {
    let s = String::from_utf8_lossy(value);

    // Try to parse as JSON
    if let Ok(json) = serde_json::from_str::<serde_json::Value>(&s) {
        serde_json::to_string_pretty(&json).unwrap_or(s.to_string())
    } else {
        s.to_string()
    }
}
```

### Color Output

```rust
use colored::*;

fn print_record(record: &Record, args: &ConsumeArgs) {
    let offset = format!("offset={}", record.offset).bright_blue();
    let value = String::from_utf8_lossy(&record.value);

    println!("{} | {}", offset, value);
}
```

---

## Configuration File

Support for `~/.streamctl.toml`:

```toml
# Default server
server = "http://localhost:50051"

# Default consumer settings
[consume]
max_records = 100
show_keys = true
show_timestamps = true

# Aliases for common operations
[aliases]
dev = "http://localhost:50051"
prod = "https://streamhouse.example.com:50051"
```

```rust
// Load config
fn load_config() -> Result<Config> {
    let config_path = dirs::home_dir()
        .ok_or("No home directory")?
        .join(".streamctl.toml");

    if config_path.exists() {
        let contents = std::fs::read_to_string(config_path)?;
        Ok(toml::from_str(&contents)?)
    } else {
        Ok(Config::default())
    }
}
```

---

## Testing

```bash
# Integration test script
#!/bin/bash

set -e

SERVER="http://localhost:50051"

# Start server (assume already running)

# Create topic
streamctl -s $SERVER topic create test --partitions 1

# Produce records
for i in {1..10}; do
    echo "{\"id\": $i}" | streamctl -s $SERVER produce test
done

# Consume and verify
RECORDS=$(streamctl -s $SERVER consume test -b | wc -l)
if [ "$RECORDS" -ne "10" ]; then
    echo "Error: Expected 10 records, got $RECORDS"
    exit 1
fi

# Cleanup
streamctl -s $SERVER topic delete test --yes

echo "✅ All tests passed"
```

---

## Deliverables

At the end of Initiative 1.7, you will have:

- [ ] **streamctl binary** with all commands
- [ ] **Topic management** (create, list, describe, delete)
- [ ] **Produce** from CLI, file, or stdin
- [ ] **Consume** with various modes (beginning, offset, follow)
- [ ] **Pretty output** formatting
- [ ] **Integration tests** using the CLI
- [ ] **User documentation** with examples

---

## Next Steps

After completing the CLI Tool (Initiative 1.7), you'll move to:

**Initiative 1.8: Testing & Documentation** - Comprehensive testing and documentation to finalize Phase 1.

---

## Dependencies

```toml
[dependencies]
streamhouse = { path = "../streamhouse-server" }
clap = { version = "4.4", features = ["derive"] }
tokio = { version = "1.35", features = ["full"] }
tonic = "0.11"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"
colored = "2.1"
chrono = "0.4"
dirs = "5.0"
```

---

## Time Estimate

**Total: 1 week** (assuming 20-25 hours of work)

- Command structure and parsing: 3-4 hours
- Topic commands: 3-4 hours
- Produce command: 3-4 hours
- Consume command: 4-5 hours
- Output formatting: 2-3 hours
- Testing and debugging: 3-4 hours
- Documentation and examples: 2-3 hours
