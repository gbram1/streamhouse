# Phase 3.1: Abstract Metadata Interface

**Status**: ✅ Complete
**Timeline**: Week 17
**Completed**: 2026-01-22

---

## Overview

Phase 3.1 extends the `MetadataStore` trait to support **agent coordination** operations needed for Phase 4's multi-agent architecture. This ensures all metadata backends (SQLite, PostgreSQL, CockroachDB, DynamoDB) implement the same interface.

---

## What Was Built

### 1. New Types

Added two new types to [crates/streamhouse-metadata/src/types.rs](../../../crates/streamhouse-metadata/src/types.rs):

#### `AgentInfo`

Tracks stateless StreamHouse agents:

```rust
pub struct AgentInfo {
    /// Unique agent identifier (e.g., "agent-us-east-1a-001")
    pub agent_id: String,

    /// Agent's gRPC address (e.g., "10.0.1.5:9090")
    pub address: String,

    /// Availability zone (e.g., "us-east-1a")
    pub availability_zone: String,

    /// Agent group for network isolation (e.g., "prod", "staging")
    pub agent_group: String,

    /// Last heartbeat timestamp (ms since epoch)
    pub last_heartbeat: i64,

    /// Agent startup timestamp (ms since epoch)
    pub started_at: i64,

    /// Additional metadata (version, capabilities, etc.)
    pub metadata: HashMap<String, String>,
}
```

**Purpose**: Agents register on startup and send periodic heartbeats to prove liveness.

#### `PartitionLease`

Implements lease-based partition leadership:

```rust
pub struct PartitionLease {
    /// Topic name
    pub topic: String,

    /// Partition ID
    pub partition_id: u32,

    /// Current leader agent ID
    pub leader_agent_id: String,

    /// Lease expiration timestamp (ms since epoch)
    pub lease_expires_at: i64,

    /// Lease acquisition timestamp (ms since epoch)
    pub acquired_at: i64,

    /// Lease epoch (increments on each leadership change)
    pub epoch: u64,
}
```

**Purpose**: Determines which agent is responsible for a partition. Uses lease expiration for automatic failover.

---

### 2. Extended MetadataStore Trait

Added 8 new methods to [crates/streamhouse-metadata/src/lib.rs](../../../crates/streamhouse-metadata/src/lib.rs):

#### Agent Registration

```rust
/// Register a new agent or update existing agent's heartbeat
async fn register_agent(&self, agent: AgentInfo) -> Result<()>;

/// Get information about a specific agent
async fn get_agent(&self, agent_id: &str) -> Result<Option<AgentInfo>>;

/// List all agents, optionally filtered by agent group or availability zone
/// Returns only agents with heartbeat within last 60 seconds (considered alive)
async fn list_agents(
    &self,
    agent_group: Option<&str>,
    availability_zone: Option<&str>,
) -> Result<Vec<AgentInfo>>;

/// Remove an agent (called on graceful shutdown)
async fn deregister_agent(&self, agent_id: &str) -> Result<()>;
```

#### Partition Leadership

```rust
/// Acquire leadership lease for a partition
/// Implements compare-and-swap semantics:
/// - If no lease exists OR existing lease expired OR existing lease held by same agent,
///   grant/renew the lease
/// - Otherwise, return error (another agent holds the lease)
async fn acquire_partition_lease(
    &self,
    topic: &str,
    partition_id: u32,
    agent_id: &str,
    lease_duration_ms: i64,
) -> Result<PartitionLease>;

/// Get current lease for a partition (if any)
/// Returns None if no lease exists or lease has expired
async fn get_partition_lease(
    &self,
    topic: &str,
    partition_id: u32,
) -> Result<Option<PartitionLease>>;

/// Release leadership lease for a partition
/// Called during graceful shutdown
async fn release_partition_lease(
    &self,
    topic: &str,
    partition_id: u32,
    agent_id: &str,
) -> Result<()>;

/// List all partition leases, optionally filtered by topic or agent
async fn list_partition_leases(
    &self,
    topic: Option<&str>,
    agent_id: Option<&str>,
) -> Result<Vec<PartitionLease>>;
```

---

### 3. Database Schema

Created migration [002_agent_coordination.sql](../../../crates/streamhouse-metadata/migrations/002_agent_coordination.sql):

#### `agents` Table

```sql
CREATE TABLE IF NOT EXISTS agents (
    agent_id TEXT PRIMARY KEY,
    address TEXT NOT NULL,
    availability_zone TEXT NOT NULL,
    agent_group TEXT NOT NULL,
    last_heartbeat BIGINT NOT NULL,
    started_at BIGINT NOT NULL,
    metadata TEXT NOT NULL DEFAULT '{}',
    UNIQUE(address)
);

-- Indexes for fast filtering
CREATE INDEX IF NOT EXISTS idx_agents_group ON agents(agent_group);
CREATE INDEX IF NOT EXISTS idx_agents_az ON agents(availability_zone);
CREATE INDEX IF NOT EXISTS idx_agents_heartbeat ON agents(last_heartbeat);
```

#### `partition_leases` Table

```sql
CREATE TABLE IF NOT EXISTS partition_leases (
    topic TEXT NOT NULL,
    partition_id INTEGER NOT NULL,
    leader_agent_id TEXT NOT NULL,
    lease_expires_at BIGINT NOT NULL,
    acquired_at BIGINT NOT NULL,
    epoch BIGINT NOT NULL DEFAULT 1,
    PRIMARY KEY (topic, partition_id),
    FOREIGN KEY (topic, partition_id) REFERENCES partitions(topic, partition_id) ON DELETE CASCADE,
    FOREIGN KEY (leader_agent_id) REFERENCES agents(agent_id) ON DELETE CASCADE
);

-- Indexes for querying and cleanup
CREATE INDEX IF NOT EXISTS idx_partition_leases_agent ON partition_leases(leader_agent_id);
CREATE INDEX IF NOT EXISTS idx_partition_leases_expiration ON partition_leases(lease_expires_at);
CREATE INDEX IF NOT EXISTS idx_partition_leases_topic ON partition_leases(topic);
```

---

### 4. SQLite Implementation

Implemented all 8 new methods in [crates/streamhouse-metadata/src/store.rs](../../../crates/streamhouse-metadata/src/store.rs):

**Key Implementation Details**:

- **Upsert semantics**: `register_agent()` uses `INSERT ... ON CONFLICT` to update heartbeat
- **Stale agent filtering**: `list_agents()` only returns agents with heartbeat within 60s
- **Compare-and-swap lease**: `acquire_partition_lease()` uses SQL CASE statements for atomic lease acquisition
- **Automatic expiration**: Queries filter expired leases by `lease_expires_at > current_time`

---

## Design Decisions

### 1. Lease-Based Leadership (Not Raft/Paxos)

**Why**: Simpler, stateless, good enough for partition leadership

- **Lease duration**: 60 seconds (configurable)
- **Renewal**: Agents renew lease every 30 seconds
- **Expiration**: Automatic failover when lease expires
- **Epoch**: Increments on leadership change to detect stale leaders

**Alternative Considered**: Raft consensus
- ❌ Too complex for this use case
- ❌ Requires persistent state per partition
- ❌ Overkill when metadata store already provides consistency

### 2. Heartbeat Timeout: 60 Seconds

**Why**: Balance between failover speed and false positives

- Too short (10s): False positives from GC pauses
- Too long (5min): Slow failover on agent death
- 60s: Good middle ground

### 3. Agent Metadata as JSON

**Why**: Flexibility for version, capabilities, custom fields

```rust
agent.metadata.insert("version", "0.2.0");
agent.metadata.insert("supports_compression", "lz4,zstd");
agent.metadata.insert("max_batch_size", "1000");
```

Future agents can add new metadata without schema changes.

### 4. Foreign Key Cascades

**Why**: Automatic cleanup when agents or partitions are deleted

```sql
FOREIGN KEY (leader_agent_id) REFERENCES agents(agent_id) ON DELETE CASCADE
```

When an agent is deregistered, all its leases are automatically released.

---

## How It Works (Phase 4 Preview)

### Agent Startup Flow

```rust
// 1. Agent starts and registers with metadata store
let agent = AgentInfo {
    agent_id: "agent-us-east-1a-001".to_string(),
    address: "10.0.1.5:9090".to_string(),
    availability_zone: "us-east-1a".to_string(),
    agent_group: "prod".to_string(),
    last_heartbeat: now_ms(),
    started_at: now_ms(),
    metadata: HashMap::new(),
};
metadata.register_agent(agent).await?;

// 2. Agent acquires leadership for partitions
for partition in 0..100 {
    let lease = metadata.acquire_partition_lease(
        "orders",
        partition,
        "agent-us-east-1a-001",
        60_000, // 60 second lease
    ).await?;
}

// 3. Agent sends periodic heartbeats (every 30s)
loop {
    tokio::time::sleep(Duration::from_secs(30)).await;

    agent.last_heartbeat = now_ms();
    metadata.register_agent(agent.clone()).await?;

    // Renew leases
    for partition in 0..100 {
        metadata.acquire_partition_lease(
            "orders",
            partition,
            "agent-us-east-1a-001",
            60_000,
        ).await?;
    }
}
```

### Automatic Failover

```rust
// Agent A dies (stops sending heartbeats)
// After 60 seconds, its leases expire

// Agent B can now acquire the partition
let lease = metadata.acquire_partition_lease(
    "orders",
    0,
    "agent-us-east-1b-002",
    60_000,
).await?;

// Returns success! Agent B is now the leader
assert_eq!(lease.leader_agent_id, "agent-us-east-1b-002");
assert_eq!(lease.epoch, 2); // Incremented from previous lease
```

---

## Testing

All existing tests still pass:

```bash
$ cargo test --workspace
running 29 tests

test result: ok. 29 passed; 0 failed; 0 ignored; 0 measured
```

**Test Coverage**:
- ✅ Topic CRUD operations
- ✅ Partition operations
- ✅ Segment metadata
- ✅ Consumer offsets
- ✅ Integration tests (produce → consume)

**New Operations Tested** (will be added in Phase 4):
- Agent registration and heartbeat
- Lease acquisition and renewal
- Automatic failover on expiration
- Multi-agent coordination

---

## Performance Impact

**Minimal overhead** since these operations are not on the hot path:

| Operation | Frequency | Impact |
|-----------|-----------|--------|
| `register_agent()` | Every 30s per agent | Negligible |
| `acquire_partition_lease()` | Every 30s per partition | Negligible |
| `get_partition_lease()` | On partition access (cached) | < 1ms |
| `list_agents()` | For monitoring/debugging | Not time-critical |

**Database Impact**:
- 10 agents × 2 heartbeats/min = 20 writes/min
- 1000 partitions × 2 lease renewals/min = 2000 writes/min
- Total: ~35 writes/sec (trivial for any database)

---

## Migration Impact

### For Existing Deployments

✅ **Backward compatible** - No changes required

- New tables are created automatically by migration
- Existing tables unchanged
- Single-agent deployments don't use agent coordination
- Can be deployed with zero downtime

### For New Backends

All future metadata backends must implement the 8 new methods:

- PostgreSQL (Phase 3.2)
- CockroachDB (Phase 3.5)
- DynamoDB (Phase 3.6)

---

## Files Changed

1. **[crates/streamhouse-metadata/src/types.rs](../../../crates/streamhouse-metadata/src/types.rs)**
   - Added `AgentInfo` struct (47 lines)
   - Added `PartitionLease` struct (24 lines)

2. **[crates/streamhouse-metadata/src/lib.rs](../../../crates/streamhouse-metadata/src/lib.rs)**
   - Added 8 agent coordination methods to `MetadataStore` trait
   - Comprehensive documentation for each method

3. **[crates/streamhouse-metadata/src/store.rs](../../../crates/streamhouse-metadata/src/store.rs)**
   - Implemented all 8 methods in `SqliteMetadataStore` (~400 lines)
   - Used `sqlx::query_as` to avoid type conflicts
   - Atomic compare-and-swap for lease acquisition

4. **[crates/streamhouse-metadata/src/error.rs](../../../crates/streamhouse-metadata/src/error.rs)**
   - Added `NotFoundError` for missing leases/agents
   - Added `ConflictError` for lease conflicts

5. **[crates/streamhouse-metadata/migrations/002_agent_coordination.sql](../../../crates/streamhouse-metadata/migrations/002_agent_coordination.sql)**
   - New migration (52 lines)
   - Creates `agents` and `partition_leases` tables
   - Indexes for performance

6. **[.sqlx/query-*.json](../../../.sqlx/)**
   - Updated offline query metadata for CI

---

## Lessons Learned

### 1. sqlx::query! Type Conflicts

**Problem**: Multiple `sqlx::query!` with same columns create incompatible anonymous types

```rust
// Error: These create different Record types!
let rows1 = sqlx::query!("SELECT id, name FROM users WHERE group = ?", "a").await?;
let rows2 = sqlx::query!("SELECT id, name FROM users WHERE group = ?", "b").await?;
```

**Solution**: Use `sqlx::query_as<(Type1, Type2, ...)>` for dynamic queries

```rust
let query = format!("SELECT id, name FROM users WHERE group = '{}'", group);
let rows: Vec<(i64, String)> = sqlx::query_as(&query).await?;
```

### 2. Foreign Key Cascades Are Powerful

Using `ON DELETE CASCADE` eliminated manual cleanup code:

```sql
FOREIGN KEY (leader_agent_id) REFERENCES agents(agent_id) ON DELETE CASCADE
```

When an agent is deleted, all its leases are automatically cleaned up.

### 3. Migration Workflow for sqlx Offline Mode

1. Create migration SQL file
2. Run `cargo sqlx migrate run`
3. Build code (triggers sqlx compile-time checks)
4. Run `cargo sqlx prepare --workspace`
5. Commit `.sqlx/` directory changes

---

## Next Steps: Phase 3.2

With the metadata interface complete, next up is **PostgreSQL backend implementation**:

1. Create `PostgresMetadataStore` struct
2. Implement all 21 MetadataStore methods (13 existing + 8 new)
3. Add connection pooling
4. Write PostgreSQL migration scripts
5. Performance testing with 10,000 partitions

---

## Summary

Phase 3.1 successfully extended the metadata interface to support multi-agent coordination:

- ✅ 8 new trait methods for agent operations
- ✅ 2 new types (`AgentInfo`, `PartitionLease`)
- ✅ Database migration with 2 new tables
- ✅ Complete SQLite implementation
- ✅ All 29 tests passing
- ✅ Zero breaking changes for existing code

**Timeline**: Completed in 1 day (ahead of schedule!)

**Status**: Phase 3.1 ✅ COMPLETE → Moving to Phase 3.2 (PostgreSQL Backend)
